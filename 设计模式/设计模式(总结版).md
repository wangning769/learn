# 设计模式的原则

## **单一职责原则**

+ **概念：**描述的意思是每个类都只负责单一的功能，切不可太多，并且一个类应当尽量的把一个功能做到极致。

## 里氏替换原则

+ **概念：**这个原则表达的意思是一个子类应该可以替换掉父类并且可以正常工作。

## 接口隔离原则

+ **概念：**也称接口最小化原则，强调的是一个接口拥有的行为应该尽可能的小。

## 依赖倒置原则

+ **概念：**这个原则描述的是高层模块不该依赖于低层模块，二者都应该依赖于抽象，抽象不应该依赖于细节，细节应该依赖于抽象。

##  迪米特原则

+ **概念：**也称最小知道原则，即一个类应该尽量不要知道其他类太多的东西，不要和陌生的类有太多接触。

## 开-闭原则

+ **概念：**对修改关闭，对扩展开放。

# 设计模式的分类

+ **创建型模式**，共五种：
  + 工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。（简单工厂模式）
+ **结构型模式**，共七种：
  + 适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
+ **行为型模式**，共十一种：
  + 策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

---

## **创建型模式**

### 创建型模式的特点和分类

> 创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“**将对象的创建与使用分离**”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。
>
> 创建型模式分为以下几种:
>
> + **单例（Singleton）模式**：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
> + **原型（Prototype）模式**：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
> + **工厂方法（FactoryMethod）模式**：定义一个用于创建产品的接口，由子类决定生产什么产品。
> + **抽象工厂（AbstractFactory）模式**：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
> + **建造者（Builder）模式**：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。

### 单例模式

+ **设计原则**：无
+ **常用场景**：应用只有对象需要是全局且唯一
  + 在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。
  + 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。
  + 如 Web 中的配置对象、数据库的连接池等。
  + 当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。
+ **选择关键点**：一个对象在应用中出现多个实例是否会引起逻辑上或者是程序上的错误
+ **角色**：
  + 单例类：包含一个实例且能自行创建这个实例的类。
  + 访问类：使用单例的类。
+ **使用概率**：99.99999%
+ **复杂度**：低
+ **变化点**：无
+ **逆鳞**：在以为是单例的情况下，却产生了多个实例
+ **相关设计模式**
  - 原型模式：单例模式是只有一个实例，原型模式每拷贝一次都会创造一个新的实例。

---

### 简单工厂模式

+ **设计原则**：遵循单一职责、违背开闭原则
+ **常用场景**：需要在一堆产品中选择其中一个产品
+ **使用概率**：99.99999%
+ **复杂度**：低

- **变化点**：产品的种类

- **选择关键点**：一种产品是否可根据某个参数决定它的种类
- **逆鳞**：工厂类不能正常工作
- **相关设计模式**
  - 工厂方法模式：工厂方法模式是简单工厂模式的进一步抽象化，在这两者之间做选择，主要看将工厂进一步抽象化是否有必要，通常情况下，如果工厂的作用仅仅是用来制造产品，则没必要使用工厂方法模式。

---

### 工厂方法模式

+ **设计原则**：遵循单一职责、依赖倒置、开闭原则
+ **常用场景**：一种场景是希望工厂与产品的种类对客户端保持透明，给客户端提供一致的操作，另外一种是不同的工厂和产品可以提供客户端不同的服务或功能
  + 客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。
  + 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。
  + 客户不关心创建产品的细节，只关心产品的品牌。
+ **角色**：
  + 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。
  + 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
  + 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
  + 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。
+ **使用概率**：60%
+ **复杂度**：中低

- **变化点**：工厂与产品的种类
- **选择关键点**：工厂类和产品类是否是同生同灭的关系

+ **逆鳞**：无

- **相关设计模式**
  - 抽象工厂模式：工厂方法模式与抽象工厂模式最大的区别在于，在工厂方法模式中，工厂创造的是一个产品，而在抽象工厂模式中，工厂创造的是一个产品族。

---

### 抽象工厂模式

+ **设计原则**：遵循单一职责、依赖倒置、开闭原则
+ **常用场景**：需要一个接口可以提供一个产品族，且不必知道产品的具体种类
  + 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。
  + 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。
  + 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。
+ **角色**：
  + 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。
  + 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
  + 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
  + 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。
+ **使用概率**：30%
+ **复杂度**：中

- **变化点**：工厂与产品的种类
- **选择关键点**：产品族是否需要一起提供，且是否有一致的接口

+ **逆鳞**：无
+ **相关设计模式**
  - 建造者模式：两者都是建造一批对象或者说产品，不同的是两者的目的和实现手段，在建造者模式中，是为了复用对象的构建过程而定义了一个**指挥者**，而在抽象工厂模式中，是为了提供一个这批对象的创建接口而定义了抽象工厂接口。

---

### 建造者模式

+ **设计原则**：遵循单一职责、开闭原则
+ **常用场景**：需要构建一批构建过程相同但表示不同的产品，对产品的结构有差异，由**指挥者**负责顶一个构建过程，而构建过程非常复杂
  + 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。
  + 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。
+ **角色**：
  + 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件。
  + 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。
  + 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。
  + 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。
+ **使用概率**：10%
+ **复杂度**：中
+ **变化点**：产品的表示
+ **选择关键点**：各个产品的构建过程是否相同
+ **逆鳞**：指挥者不能正常工作

---

### 原型模式

+ **设计原则**：无
+ **常用场景**：需要在运行时动态的创建指定实例种类的对象，或是需要复用其状态
  + 对象之间相同或相似，即只是个别的几个属性不同的时候。
  + 对象的创建过程比较麻烦，但复制比较简单的时候。
+ **使用概率**：10%
+ **角色**：
  + 抽象原型类：规定了具体原型对象必须实现的接口。
  + 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。
  + 访问类：使用具体原型类中的 clone() 方法来复制新的对象。
+ **复杂度**：中低
+ **变化点**：无 
+ **选择关键点**：创建出来的对象是否可以立即投入使用
+ **逆鳞**：在以为是深度拷贝的情况下，却未实现深度拷贝

---

## **结构型设计模式**

### 结构型模式的特点和分类

>结构型模式描述如何将类或对象按某种布局组成更大的结构。**它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。**
>
>+ **代理（Proxy）模式**：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
>+ **适配器（Adapter）模式**：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
>+ **桥接（Bridge）模式**：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
>+ **装饰（Decorator）模式**：动态地给对象增加一些职责，即增加其额外的功能。
>+ **外观（Facade）模式**：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
>+ **享元（Flyweight）模式**：运用共享技术来有效地支持大量细粒度对象的复用。
>+ **组合（Composite）模式**：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
>
>以上 7 种结构型模式，除了适**配器模式**分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式。

### 代理模式

+ **设计原则**：体现功能复用
+ **常用场景**：需要修改或屏蔽某一个或若干个类的部分功能，复用另外一部分功能，可使用静态代理，若是需要拦截一批类中的某些方法，在方法的前后插入一些一致的操作，假设这些类有一致的接口，可使用JDK的动态代理，否则可使用cglib
  + 远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。
  + 虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。
  + 安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。
  + 智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。
  + 延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。
+ **角色**:
  + 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
  + 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
  + 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。
+ **使用概率**：99.99999%
+ **复杂度**：中高
+ **变化点**：静态代理没有变化点，动态代理的变化点为具有相同切入点的类
+ **选择关键点**：静态代理选择的关键点是是否要复用被代理的部分功能，动态代理选择的关键点在于能否在将被代理的这一批类当中，找出相同的切入点
+ **逆鳞**：切入点的不稳定
+ **相关设计模式**
  - 适配器模式：对于适配器模式当中的定制适配器，它与静态代理有着相似的部分，二者都有复用功能的作用，不同的是，静态代理会修改一部分原有的功能，而适配器往往是全部复用，而且在复用的同时，适配器还会将复用的类适配一个接口

---

### 适配器模式

+ **设计原则**：遵循开闭原则、体现功能复用
+ **常用场景**：需要使用一个类的功能，但是该类的接口不符合使用场合要求的接口，可使用定制适配器，又或者是有一个接口定义的行为过多，则可以定义一个缺省适配器，让子类选择性的覆盖适配器的方法
  + 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
  + 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。
+ **角色**：
  + 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。
  + 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。
  + 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。
+ **使用概率**：40%
+ **复杂度**：中
+ **复杂度**：中
+ **选择关键点**：定制适配器的选择关键点在于是否有更加优良的替代方案，缺省适配器的选择关键点在于接口中的方法是否可以不全部提供，且都有缺省方案,
+ **类结构型模式**和**对象结构型模式**两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。
+ **逆鳞**：无
+ **相关设计模式**
  - 装饰器模式：对于适配器模式中的定制适配器与装饰器模式，二者都是使用组合加继承的手段，不同的是，适配器模式的目的在于适配接口，装饰器模式的目的在于动态的添加功能，且可以叠加。

---

### 装饰器模式

+ **设计原则**：遵循迪米特、单一职责、开闭原则，破坏里氏替换，体现功能复用
+ **常用场景**：一个类需要动态的添加功能，且这些功能可以相互叠加
  + 当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。
  + 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。
  + 当对象的功能要求可以动态地添加，也可以再动态地撤销时。
+ **角色**：
  + 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
  + 具体构件（Concrete  Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。
  + 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
  + 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。
+ **使用概率**：99.99999%
+ **复杂度**：中
+ **变化点**：动态添加的功能或者说装饰器
+ **选择关键点**：添加的功能是否需要动态组装
  + 指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。

---

### 桥接模式

+ **设计原则**：遵循单一职责、迪米特、开闭原则，体现功能复用
+ **常用场景**：一个对象有多个维度的变化，需要将这些维度抽离出来，让其独立变化
  + 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。
  + 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。
  + 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。
+ **角色**：
  + 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。
  + 扩展抽象化（Refined  Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
  + 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。
  + 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。
+ **使用概率**：20%

- **复杂度**：中高
- **变化点**：维度的扩展与增加
- **选择关键点**：是否可以将对象拆分成多个不相关的维度
  - 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
- **逆鳞**：无

---

### 组合模式

+ **设计原则**：遵循依赖倒置、开闭原则，破坏接口隔离
+ **常用场景**：当有一个结构可以组合成树形结构，且需要向客户端提供一致的操作接口，使得客户端操作忽略简单元素与复杂元素
  + 在需要表示一个对象整体与部分的层次结构的场合。
  + 要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。
+ **角色**：
  + 抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。
  + 树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。
  + 树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。
+ **使用概率**：30%
+ **复杂度**：中
+ **变化点**：节点的数量
+ **选择关键点**：对外提供一致操作接口的结构是否可转化为树形结构
  + 它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。
  + 组合模式分为**透明式的组合模式**和**安全式的组合模式**
+ **逆鳞**：结构不稳定或结构中的节点有递归关系

---

### 享元模式

- **设计原则**：无
- **常用场景**：一些状态相同的对象被大量的重复使用
  - 系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。
  - 大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。
  - 由于享元模式需要额外维护一个保存享元的**数据结构**，所以应当在有足够多的享元实例时才值得使用享元模式。
- **角色**：
  - 抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。
  - 具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。
  - 非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。
  - 享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。
- **使用概率**：90%
- **复杂度**：中
- **变化点**：无
- **选择关键点**：被共享的对象是否可以将外部状态提取出来
  - **内部状态**：即不会随着环境的改变而改变的可共享部分；
  - **外部状态**：指随环境改变而改变的不可以共享的部分。
  - 享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。下面来分析其基本结构和实现方法。
- **逆鳞**：没有将外部状态提取完全

---

### 外观模式 

- **设计原则**：遵循迪米特
- **常用场景**：一个子系统需要对外提供服务
  - 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。
  - 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。
  - 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。
- **角色**：
  - 外观（Facade）角色：为多个子系统对外提供一个共同的接口。
  - 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。
  - 客户（Client）角色：通过一个外观角色访问各个子系统的功能。
- **使用概率**：60%
- **复杂度**：中
- **变化点**：无
- **选择关键点**：子系统对外提供服务是否需要依赖很多的类
  - 相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。

+ **逆鳞**：子系统对外提供的服务的变化或子系统本身的不稳定

+ **相关设计模式**
  - 中介者模式：二者都是为了处理复杂的耦合关系，不同的是外观模式处理的是类之间复杂的依赖关系，中介者模式处理的是对象之间复杂的交互关系

---

## **行为型设计模式**

### 行为型模式的特点和分类

+ 行为型模式用于描述程序在运行时复杂的流程控制，即描述**多个类或对象**之间怎样相互**协作共同完成**单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。

> **行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。**由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。
>
> 

### 观察者模式

+ **设计原则**：遵循迪米特、开闭原则
+ **常用场景**：需要将观察者与被观察者解耦或者是观察者的种类不确定
+ **使用概率**：40%

- **复杂度**：中
- **变化点**：观察者的种类与个数
- **选择关键点**：观察者与被观察者是否是多对一的关系
- **逆鳞**：观察者之间有过多的细节依赖

---

### 模板方法模式

+ **设计原则**：破坏里氏替换原则，体现功能复用

+ **常用场景**：一批子类的功能有可提取的公共算法骨架
+ **使用概率**：80%

- **复杂度**：中低
- **变化点**：算法骨架内各个步骤的具体实现
- **选择关键点**：算法骨架是否牢固
- **逆鳞**：无

---

### 命令模式

+ **设计原则**：遵循迪米特、开闭原则

+ **常用场景**：行为的请求者与行为的处理者耦合度过高
+ **使用概率**：20%
+ **复杂度**：中高

+ **变化点**：命令的种类

+ **选择关键点**：请求者是否不需要关心命令的执行只知道接受者

+ **逆鳞**：命令的种类无限制增长

+ **相关设计模式**
  + 职责链模式：容易将二者关联在一起的原因是，二者都是为了处理请求或者命令而存在的，而且二者都是为了将请求者与响应者解耦，不同的是命令模式中，客户端需要知道一个命令的接受者，在创建命令的时候就把接受者与命令绑定在一起发送给调用者，而职责链模式中，客户端并不关心最终处理请求的对象是谁，客户端只是封装一个请求对象，随后交给职责链的头部而已，也正因为这样，二者的实现方式，有着很大的区别 

---

### 状态模式

+ **设计原则**：遵循单一职责、依赖倒置、开闭原则
+ **常用场景**：一个对象在多个状态下行为不同，且这些状态可互相转换
+ **使用概率**：20%
+ **复杂度**：中
+ **变化点**：状态的种类

+ **选择关键点**：这些状态是否经常在运行时需要在不同的动态之间相互转换
+ **逆鳞**：无

+ **相关设计模式**
  - 策略模式：二者的实现方式非常相似，策略接口与状态接口，具体的策略与具体的状态以及二者都拥有的上下文，如果看它们的类图，会发现几乎一模一样，而二者不同的地方就在于，状态模式经常会在处理请求的过程中更改上下文的状态，而策略模式只是按照不同的算法处理算法逻辑，而且从实际场景来讲，顾名思义，状态模式改变的是状态，策略模式改变的是策略

---

### 责任链模式

+ **设计原则**：遵循迪米特
+ **常用场景**：一个请求的处理需要多个对象当中的一个或几个协作处理
+ **使用概率**：15%
+ **复杂度**：中

+ **变化点**：处理链的长度与次序

+ **选择关键点**：对于每一次请求是否每个处理的对象都需要一次处理机会

+ **逆鳞**：无

---

### 解释器模式

+ **设计原则**：遵循单一职责
+ **常用场景**：有一种语言被频繁的使用
+ **使用概率**：0.00009%
+ **复杂度**：中高

+ **变化点**：语言的规则

- **选择关键点**：被频繁使用的语言是否可用文法表示
- **逆鳞**：语言的规则无限制增长或规则十分不稳定

---

### 中介者模式

+ **设计原则**：遵循迪米特，破坏单一职责

+ **常用场景**：一个系列的对象交互关系十分复杂

- **使用概率**：10%
- **复杂度**：中
- **变化点**：对象之间的交互

- **选择关键点**：复杂的交互关系是否有共性可被中介者承担
- **逆鳞**：中介者无法工作

---

### 访问者模式

+ **设计原则**：遵循倾斜的开闭原则

+ **常用场景**：作用于一个数据结构之上的操作经常变化

- **使用概率**：5%
- **复杂度**：高
- **变化点**：数据结构之上的操作
- **选择关键点**：数据结构是否稳定以及操作是否经常变化
- **逆鳞**：数据结构的不稳定 

---

### 策略模式

- **设计原则**：遵循单一职责、依赖倒置、迪米特、开闭原则
- **常用场景**：算法或者策略需要经常替换
- **使用概率**：60%
- **复杂度**：中
- **变化点**：策略的种类
- **选择关键点**：客户端是否依赖于某一个或若干个具体的策略
- **逆鳞**：无

---

### 备忘录模式

+ **设计原则**：遵循迪米特、开闭原则

+ **常用场景**：需要在对象的外部保存该对象的内部状态

- **使用概率**：5%
- **复杂度**：中
- **变化点**：无
- **选择关键点**：是否可以在必要的时候捕捉到对象的内部状态
- **逆鳞**：大对象的备份

---

### 迭代器模式

+ **设计原则**：遵循迪米特

+ **常用场景**：需要迭代访问一个聚合对象中的各个元素，且不暴露该聚合对象内部的表示

- **使用概率**：99.99999%
- **复杂度**：中
- **变化点**：聚合对象的种类
- **选择关键点**：客户端是否关心遍历的次序
- **逆鳞**：无

+ **相关设计模式**
  + 访问者模式：二者都是迭代的访问一个聚合对象中的各个元素，不同的是，访问者模式中，扩展开放的部分在作用于对象的操作上，而迭代器模式中，扩展开放的部分在聚合对象的种类上，而且二者的实现方式也有着很大的区别。



---

# 附录

**组合或聚合**：A类中包含B类的一个bai引用b，当A类的一个对象消亡时，b这个引用所指向的对象也同时消亡（没有任何一个引用指向它，成了垃圾对象），这种情况叫做组合，反之b所指向的对象还会有另外的引用指向它，这种情况叫聚合。

---

[原博客地址](https://www.cnblogs.com/zuoxiaolong/category/509144.html)